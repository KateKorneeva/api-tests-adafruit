"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.validateBySchema = exports.deleteFeed = exports.createFeed = exports.responseErrMessage = exports.logout = exports.auth = exports.getApi = void 0;

var _axios = _interopRequireDefault(require("axios"));

var _tv = _interopRequireDefault(require("tv4"));

var _fixtures = require("./fixtures");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getApi = async () => {
  const client = _axios.default.create({
    baseURL: _fixtures.BASE_URL + _fixtures.ADAFRUIT_IO_USERNAME,

    validateStatus() {
      return true;
    }

  });

  return client;
};

exports.getApi = getApi;

const auth = api => {
  api.defaults.headers['X-AIO-Key'] = _fixtures.ADAFRUIT_IO_KEY;
};

exports.auth = auth;

const logout = api => {
  delete api.defaults.headers['X-AIO-Key'];
};

exports.logout = logout;

const responseErrMessage = response => {
  return JSON.stringify(response.data, null, 2);
};

exports.responseErrMessage = responseErrMessage;

const createFeed = async (t, api, feedObject = _fixtures.feedObject) => {
  const resp = await api.post('/feeds', feedObject);
  t.is(resp.status, 201, responseErrMessage(resp));
  return resp.data;
};

exports.createFeed = createFeed;

const deleteFeed = async (t, api, feedKey) => {
  const resp = await api.delete(`/feeds/${feedKey}`);
  t.is(resp.status, 200, responseErrMessage(resp));
  return resp.data;
};

exports.deleteFeed = deleteFeed;

const validateBySchema = (t, data, schema) => {
  if (!_tv.default.validate(data, schema)) {
    // if simple schema validation returns false
    const errors = _tv.default.validateMultiple(data, schema).errors;

    errors.forEach(error => {
      const objectWithErr = getObjectContainingValue(data, error.dataPath);
      const failMessage = 'Schema validation error:\n' + error.message + '\n dataPath:   ' + error.dataPath + '\n Object with error:' + objectWithErr;
      t.fail(failMessage);
    });
  }
};

exports.validateBySchema = validateBySchema;

const getObjectContainingValue = (data, dataPath) => {
  let pathArr = dataPath.split('/');
  let val = data;
  pathArr.pop(); // remove the last element of the path because we want to see bigger picture

  if (pathArr[0] === '') {
    pathArr.shift();
  } // remove empty string which may happen to be the first element


  for (let i in pathArr) {
    if (isNaN(parseInt(pathArr[i]))) {
      // if element is not an int
      val = val[pathArr[i]];
    } else if (!isNaN(parseInt(pathArr[i]))) {
      // if element is an int
      val = val[parseInt(pathArr[i])];
    }
  }

  return JSON.stringify(val, null, 2); // pretty JSON output
};
//# sourceMappingURL=/home/kate/moeco/adafruit/node_modules/.cache/ava/bb2c5a1c7dedc1d5c1b1eb21d71f926d.js.map